\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{moreverb}
\usepackage{graphicx}
\title{Project Report for WeezelTV\\ EDA095 Network Programming}
\date{\today}
\author{Fredrik Paulsson \\ dat11fp1@student.lu.se \and Jonas Jacobsson \\ dat11jja@student.lu.se \and Artur Matulaniec \\ dat11ama@student.lu.se \and Magnus TÃ¶rnquist \\ ada08mto@student.lu.se}
%\setcounter{secnumdepth}{5}
%\setcounter{tocdepth}{5}
\begin{document}
\maketitle
%\tableofcontents

\newpage
\section{Introduction}
The project in this course did not contain a specific task that was to be done. Rather the only demand was that the content of the course was to be of central focus in the project.

Since the course was about network programming we decided that our project were to be based on video streaming. Basically we wanted to stream video from a server to a client. At first we wanted to implement the server part using well-known protocols such as RTSP/RTCP/RTP and then connect our server to an already existing client such as VLC.

However, later on we decided to skip these existing protocols and implement our own client/server solution using a simple protocol that we ourselves defined.

This report will serve as documentation of our project work.

\section{Implementing a server using RTP/RTSP}
As mentioned in the introduction we started off the project by trying to implement a RTP/RTSP server hoping to be able to stream to VLC. 
Some sample code was provided to us containing a server and client using a very simplified version of RTP/RTSP. The server used RTSP to setup the connection with the client then created byte arrays of jpeg images from a file in the mjpeg format.
This code was our main foundation for trying to build a RTP server capable of streaming to VLC instead of the provided client. Unfortunately it turned out that there were many obstacles in the way.
First we encountered several small problems, for example the sample code did not use EOL properly and thus VLC didn't know the server had finished sending an RTSP packet. Another example is that the server wanted responses to look in particular way and couldn't understand what VLC was sending.
A third example is that VLC wanted to decide the client port in the SETUP method and therefore we had to extract that and use the port in the connection.
These problems were rather easily fixed. Then came a slightly bigger problem: It turned out that VLC required the RTSP method "DESCRIBE" to be used even though the RFC for RTSP states that it's only a recommended method  (https://www.ietf.org/rfc/rfc2326.txt).
Implementing a DESCRIBE method that was fully functional in all cases would be tricky (see section 10.2 in the RFC), so we decided to focus on giving VLC the correct information for that particular mjpeg file. 
When this was done VLC was finally satisfied and a connection was established, but for some reason no packets were being received on the clients end. It was just waiting until it timed out.
We fired up Wireshark to analyze what had gone wrong and saw plenty of packets that Wireshark did not recognize. After further inspection we realized that those were our RTP packets but with an incorrect header.
The RTP sample code had completely skipped the beginning of the header that includes important things like padding and payload type. So we figured out what we wanted the header to be and manually set the beginning of the header to [10000000] (see https://www.ietf.org/rfc/rfc3550.txt for details) and payload type 26 (mjpeg).
Now VLC was finally receiving the packets, recognizing them as RTP packets with an mjpeg payload and handed of the decoding procedure to the open source library "LIVE555".
LIVE555 failed to decode the packets. This was when we started to run of patience. It turned out that when sending mjpeg via RTP it requires a special header on all jpeg images. 
When we were taking a look at the RFC for RTP Payload Format for JPEG-compressed Video (found here: https://tools.ietf.org/html/rfc2435) we realized that we had bitten of more than we could chew and decided to scrap this whole approach.

This code is still available but we decided not to include it here since it's irrelevant to the rest of the project. 

\section{Features/Requirements}
When we began our project we did set quite straight forward requirements regarding what we wanted our software to handle. To begin with we did some research and thought of using an already implemented protocol in order to be able to use standard software regarding the video showing, as mentioned before. Hence, the main objective of our software was that we would implement a server, a client and be able to connect to that server, preferably with more than one client at a time, and stream video to it/them in real time. Along the way, however, more features came to our minds and we did found ourselves having requirements as show in the list below.

\begin{itemize}
\item A server with some videos and being able to handle more than one client at a time.
\item A client with our own GUI.
\item The possibility of choosing a video to stream.
\item Being able to play and pause, both the stream and the video.
\item To have the video streamed with audio.
\item Building our own protocol in order to minimize the complexity of the software. 
\end{itemize}

Those were the features which we finally decided to add to our software and project. 


\section{Structure/Model}
Our solution consists of two parts, a server and a client. These are two independent programs that communicates using a protocol that we personally defined. The underlying transport protocol is, however, regular TCP. Since we have two different independent programs we will divide this section in order to describe each and one of them more specifically. There is also a common packet shared by the two programs in order for them to be able to communicate. 

\subsection{Common}
Under this packet we have both the protocol and the common configuration file, which is use to maintain all the parameters into the program. The protocol consists of a couple of bytes which are sent over the network to one of the entities in order to perform commands from one entity to the other. Under this common packet we also have the two buffer element types, 
\begin{itemize}
\item \texttt{AudioBufferElement}
\item \texttt{ImageBufferElement}
\end{itemize}

which describes the elements of both the video and audio in order to send them over the network. As well as their structure is considered crucial in order to maintain the synchronization between the two parts when streaming video over the network. 

\subsubsection{Protocol}
Since this project is about network programming some information about the protocol could be explained. Our protocol uses regular bytes as the data to be sent, since then there is no need for converting any other data type. We have divided it into two parts, 

\begin{enumerate} 
\item Server to client commands
\item Client to server commands
\end{enumerate}

to be able to divide the communication, and also for the ease of adding new commands throughout. 

\subsection{Server}
The server is divided into different classes for the maintainability of the server. However, the most important part is the \texttt{ServerSender} class. This class is the class which sends the data over the network, for both image and audio samples. This is the monitor shared by the two threads, \texttt{ImageSender} and \texttt{AudioSender}, which are responsible to provide the monitor with samples to be sent to a connected client. 

The server also has a buffer, the class \texttt{ServerBuffer}, which holds the samples. The common structure for the buffers is that they both use LinkedList as the data container. The class \texttt{ServerListener} is a class which encodes the file found on the server into the two common shared data structures mentioned above. This class is responsible to provide the buffer with the samples in order for the two senders, \texttt{ImageSender} and \texttt{AudioSender} to be able to send the information to the \texttt{ServerSender} and next out on the network.

To be able to read any commands sent from the client, the thread \texttt{ServerReceiver} is running and reading the bytes sent from the client. Based on which command is being sent, it performs different action on the buffer and in that way the server is controlled by the client. 

The main method of the server is to be found in the class \texttt{Server}.   
\subsection{Client}
The client is also divided into a couple of classes for the maintainability of the software. The most important part of the client is the thread \texttt{ClientReceiver}. The thread is responsible to receive the sent information from the server and sends it into the clients buffer, class \texttt{ClientBuffer}. The buffer then works as a monitor for the rest of the client, since all the other threads also uses it to receive information and show it onto the GUI. As in the server, the buffer uses LinkedList as the data container and there are two, one for each of the common shared data elements. 

Another important part of the client is the two threads, \texttt{ClientImageViewer} and \texttt{ClientSoundPlayer}. Those threads are responsible for the synchronization between the video and the audio. The \texttt{ClientImageViewer} is also responsible to add image samples into the GUI in order to show the video stream. 

The GUI, class \texttt{ClientGUI} is responsible for everything that happens with the end user. The GUI takes use of the monitor, \texttt{ClientSender}, to be able to send commands to the server from the client. The \texttt{ClientSender} is responsible to maintain the connection with the \texttt{ServerReceiver} in order for the end user to send commands from the client to the server. 

The main method for the client is to be found in the class \texttt{Client}. 
\subsection{Library}
%Här beskriver vi xuggle lite kortfattat, lägg gärna till referenser. Problemen med xuggle tykcer jag vi tar i diskussionen

\section{User Guide}
%manual

\section{Evaluation/Discussion}
%kolla rapportgrejsen som jag lÃ¤nkat till: http://fileadmin.cs.lth.se/cs/Education/EDA095/2010/projektrapport.pdf
\section{Source Code}
%Vi beskriver bara hur källkoden är organiserad, för mycket att inkludera allt




\begin{thebibliography}{1}
\bibitem{wikipedia}
http://en.wikipedia.org
\end{thebibliography}
\end{document}
