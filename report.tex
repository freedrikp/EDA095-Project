\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{moreverb}
\usepackage{graphicx}
\title{Project Report \\ EDA095 Network Programming}
\date{\today}
\author{Fredrik Paulsson \\ dat11fp1@student.lu.se \and Jonas Jacobsson \\ dat11jja@student.lu.se \and Artur Matulaniec \\ dat11ama@student.lu.se \and Magnus Törnquist \\ ada08mto@student.lu.se}
%\setcounter{secnumdepth}{5}
%\setcounter{tocdepth}{5}
\begin{document}
\maketitle
%\tableofcontents

\section{Introduction}
The project in this course did not contain a specific task that was to be done. Rather the only demand was that the content of the course was to be of central focus in the project.

Since the course was about network programming we decided that our project were to be based on video streaming. Basically we wanted to stream video from a server to a client. At first we wanted to implement the server part using well-known protocols such as RTSP/RTCP/RTP and then connect our server to an already existing client such as VLC.

However, later on we decided to skip these existing protocols and implement our own client/server solution using a simple protocol that we ourselves defined.

This report will serve as documentation of our project work.

\section{Implementing a server using RTP/RTSP}
As mentioned in the introduction we started off the project by trying to implement a RTP/RTSP server hoping to be able to stream to VLC. 
Some sample code was provided to us containing a server and client using a very simplified version of RTP/RTSP. The server used RTSP to setup the connection with the client then created byte arrays of jpeg images from a file in the mjpeg format.
This code was our main foundation for trying to build a RTP server capable of streaming to VLC instead of the provided client. Unfortunately it turned out that there were many obstacles in the way.
First we encountered several small problems, for example the sample code did not use EOL properly and thus VLC didn't know the server had finished sending an RTSP packet. Another example is that the server wanted responses to look in particular way and couldn't understand what VLC was sending.
A third example is that VLC wanted to decide the client port in the SETUP method and therefore we had to extract that and use the port in the connection.
These problems were rather easily fixed. Then came a slightly bigger problem: It turned out that VLC required the RTSP method "DESCRIBE" to be used even though the RFC for RTSP states that it's only a recommended method  (https://www.ietf.org/rfc/rfc2326.txt).
Implementing a DESCRIBE method that was fully functional in all cases would be tricky (see section 10.2 in the RFC), so we decided to focus on giving VLC the correct information for that particular mjpeg file. 
When this was done VLC was finally satisfied and a connection was established, but for some reason no packets were being received on the clients end. It was just waiting until it timed out.
We fired up Wireshark to analyze what had gone wrong and saw plenty of packets that Wireshark did not recognize. After further inspection we realized that those were our RTP packets but with an incorrect header.
The RTP sample code had completely skipped the beginning of the header that includes important things like padding and payload type. So we figured out what we wanted the header to be and manually set the beginning of the header to [10000000] (see https://www.ietf.org/rfc/rfc3550.txt for details) and payload type 26 (mjpeg).
Now VLC was finally receiving the packets, recognizing them as RTP packets with an mjpeg payload and handed of the decoding procedure to the open source library "LIVE555".
LIVE555 failed to decode the packets. This was when we started to run of patience. It turned out that when sending mjpeg via RTP it requires a special header on all jpeg images. 
When we were taking a look at the RFC for RTP Payload Format for JPEG-compressed Video (found here: https://tools.ietf.org/html/rfc2435) we realized that we had bitten of more than we could chew and decided to scrap this whole approach.

This code is still available but we decided not to include it here since it's irrelevant to the rest of the project. 

\section{Features/Requirements}
When we began our project we did set quite straight forward requirements regarding what we wanted our software to handle. To begin with we did some research and thought of using an already implemented protocol in order to be able to use standard software regarding the video showing. 

\section{Structure/Model}
Our solution consists of two parts, a server and a client. These are two independent programs that communicates using a protocol that we have oursleves defined. The communication uses a TCP connection.

\subsection{Library}
Här beskriver vi xuggle lite kortfattat, lägg gärna till referenser. Problemen med xuggle tykcer jag vi tar i diskussionen

\subsection{Client}
Viktigaste klasser och annat tekniskt hur klienten fungerar

\subsection{Server}
samma här fast för servern

\subsection{Protocol}
beskrivning av protokollet

\section{User Guide}
manual

\section{Evaluation/Discussion}
kolla rapportgrejsen som jag länkat till: http://fileadmin.cs.lth.se/cs/Education/EDA095/2010/projektrapport.pdf
\section{Source Code}
Vi beskriver bara hur källkoden är organiserad, för mycket att inkludera allt




\begin{thebibliography}{1}
\bibitem{wikipedia}
http://en.wikipedia.org
\end{thebibliography}
\end{document}
